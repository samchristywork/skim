<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skim</title>
    <style>
body {
  font-family: sans-serif;
  margin: 0;
  padding: 20px;
  background-color: #f4f4f4;
  color: #333;
}

.content {
  max-width: 800px;
  margin: auto;
  background: white;
  padding: 20px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  position: relative;
}

.input-controls {
  display: flex;
  flex-direction: column;
  margin-bottom: 20px;
}

#textInput {
  width: 100%;
  height: 150px;
  padding: 10px;
  margin-bottom: 10px;
  box-sizing: border-box;
  border: 1px solid #ccc;
  font-size: 16px;
}

.controls-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#loadButton,
#playPauseButton {
  background-color: #008CBA;
  color: white;
  padding: 10px 15px;
  border: none;
  cursor: pointer;
  border-radius: 5px;
  font-size: 16px;
}

#loadButton {
  background-color: #4CAF50;
}

#speedControl {
  display: flex;
  align-items: center;
}

#speedLabel {
  margin-right: 5px;
  color: #555;
  font-size: 14px;
}

#speed {
  width: 60px;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

p {
  line-height: 1.6;
  margin-bottom: 15px;
  margin-top: 0;
}

.highlight {
  background-color: yellow;
}

.time {
  text-align: right;
  font-size: 0.9em;
  color: #777;
  margin-top: 10px;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}
    </style>
  </head>
  <body>
    <div class="content">
      <div class="input-controls">
        <textarea id="textInput" placeholder="Enter your text here..."></textarea>
        <div class="controls-row">
          <button id="loadButton">Load Text</button>
          <button id="playPauseButton">Play</button>
          <div id="speedControl">
            <label id="speedLabel" for="speed">Speed:</label>
            <input type="number" id="speed" value="20" min="1" max="100" step="1">
          </div>
        </div>
      </div>
      <div class="time"><span id="time"></span></div>
    </div>
  </body>
  <script>
    let isPaused = true;
    let currentTimeout;
    let isHighlighting = false;

    let elementIndex = 0;
    let charIndex = 0;

    let elements = [];
    let totalChars = 0;

    let speed = 20;

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function processTextToElements(text) {
      const contentDiv = document.querySelector(".content");
      const paragraphs = contentDiv.querySelectorAll('p');
      paragraphs.forEach(p => p.remove());

      elements = [];
      totalChars = 0;

      text.split("\n").forEach((line) => {
        line = line.trim();
        if (line === "") return;
        let p = document.createElement("p");
        p.textContent = line;
        elements.push(p);
        contentDiv.appendChild(p);
        totalChars += line.length;

        p.addEventListener('click', () => {
          stopHighlighting();
          resetHighlighting();
          charIndex = 0;
          elementIndex = elements.indexOf(p);
          isPaused = false;
          highlightText();
        });
      });

      return {
        elements,
        totalChars
      };
    }

    function setTotalTime(totalChars, timePerChar) {
      let timeElement = document.getElementById('time');
      const ms = totalChars * timePerChar;
      const s = Math.ceil(ms / 1000);
      const t = s > 60 ? `${Math.floor(s / 60)}m ${s % 60}s` : `${s}s`;
      timeElement.textContent = t;
    }

    async function highlightCharacter(child, textContent, i, timePerChar) {
      if (isPaused) {
        await waitForResume();
      }

      let before = textContent.slice(0, i);
      let char = textContent[i];
      let after = textContent.slice(i + 1);
      let highlightedHTML = `${before}<span class="highlight">${char}</span>${after}`;
      child.innerHTML = highlightedHTML;

      scrollToHighlightedCharacter(child);

      await sleep(timePerChar);
    }

    function scrollToHighlightedCharacter(child) {
      const highlightedSpan = child.querySelector('.highlight');
      if (highlightedSpan) {
        const elementTop = highlightedSpan.offsetTop;
        const elementHeight = highlightedSpan.offsetHeight;
        const screenHeight = window.innerHeight;
        const scrollTo = elementTop - (screenHeight / 3) + (elementHeight / 2);

        window.scrollTo({
          top: scrollTo,
          behavior: 'smooth'
        });
      }
    }

    async function waitForResume() {
      return new Promise(resolve => {
        const checkPause = () => {
          if (!isPaused) {
            resolve();
          } else {
            currentTimeout = setTimeout(checkPause, 100);
          }
        };
        checkPause();
      });
    }

    async function highlightText() {
      if (isHighlighting) {
        return;
      }
      isHighlighting = true;

      setTotalTime(totalChars, speed);

      try {
        while (elementIndex < elements.length) {
          const child = elements[elementIndex];
          const textContent = child.textContent;

          await highlightCharacter(child, textContent, charIndex, speed);
          charIndex++;

          if (charIndex >= textContent.length) {
            child.innerHTML = textContent;
            elementIndex++;
            charIndex = 0;

            if (elementIndex >= elements.length) {
              break;
            }
          }
        }
      } catch (error) {
        console.error("Error processing content:", error);
      } finally {
        isHighlighting = false;
      }
    }

    function stopHighlighting() {
      isPaused = true;
      clearTimeout(currentTimeout);
    }

    function resetHighlighting() {
      elements.forEach(el => el.innerHTML = el.textContent);
      elementIndex = 0;
      charIndex = 0;
      isPaused = false;
      playPauseButton.textContent = 'Pause';
    }

    const playPauseButton = document.getElementById('playPauseButton');
    const loadButton = document.getElementById('loadButton');
    const textInput = document.getElementById('textInput');
    const speedInput = document.getElementById('speed');

    playPauseButton.addEventListener('click', () => {
      isPaused = !isPaused;
      playPauseButton.textContent = isPaused ? 'Play' : 'Pause';
      if (!isPaused) {
        highlightText();
      }
    });

    document.addEventListener('keydown', (event) => {
      if (document.activeElement === textInput) {
        return;
      }

      if (event.code === 'Space') {
        event.preventDefault();
        isPaused = !isPaused;
        playPauseButton.textContent = isPaused ? 'Play' : 'Pause';
        if (!isPaused) {
          highlightText();
        }
      } else if (event.code === 'ArrowRight' || event.code === 'KeyN') {
        if (elementIndex < elements.length - 1) {
          elements[elementIndex].innerHTML = elements[elementIndex].textContent;
          elementIndex++;
          charIndex = 0;
          isPaused = false;
          playPauseButton.textContent = 'Pause';
          highlightText();
        }
      } else if (event.code === 'ArrowLeft' || event.code === 'KeyP') {
        if (elementIndex > 0) {
          elements[elementIndex].innerHTML = elements[elementIndex].textContent;
          elementIndex--;
          charIndex = 0;
          isPaused = false;
          playPauseButton.textContent = 'Pause';
          highlightText();
        }
      } else if (event.code === 'ArrowUp') {
        event.preventDefault();
        speed = Math.max(1, speed - 1);
        speedInput.value = speed;
        setTotalTime(totalChars, speed);
      } else if (event.code === 'ArrowDown') {
        event.preventDefault();
        speed = Math.min(100, speed + 1);
        speedInput.value = speed;
        setTotalTime(totalChars, speed);
      } else if (event.code === 'KeyR') {
        resetHighlighting();
        highlightText();
      } else {
        console.log('Other key pressed:', event.code);
      }
    });

    loadButton.addEventListener('click', async () => {
      const text = textInput.value;
      const result = await processTextToElements(text);
      elements = result.elements;
      totalChars = result.totalChars;
      resetHighlighting();
      highlightText();
    });

    speedInput.addEventListener('change', () => {
      speed = parseInt(speedInput.value, 10);
      if (isNaN(speed) || speed < 1) {
        speed = 1;
        speedInput.value = 1;
      }
      setTotalTime(totalChars, speed);
    });
  </script>
</html>
